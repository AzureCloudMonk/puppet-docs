---
layout: default
title: "Cómo instalar y usar Windows modules"
---

<h2 id="windows-module-pack">Paquete de "module" para Windows</h2>

<p> Puppet Forge es una comunidad online de Puppet modules publicados por Puppet y miembros de la comunidad. Forge facilita la gestión de Puppet y puedes ahorrar tiempo utilizando "modules"  pre-escritos, en lugar de escribirlos usted mismo. Además puede ser calificado por la comunidad, "modules" en Forge es <a href="https://forge.puppetlabs.com/approved">Puppet Approved</a> o <a href="https://forge.puppetlabs.com/supported">Puppet Supported</a>. La mayor diferencia es que  "Approved modules" no están disponibles para <a href="https://puppetlabs.com/services/customer-support">el servicio de soporte de Puppet Enterprise</a>, pero todavía se prueban y se adhieren a un estándar por el estilo y la calidad.
</p>

<p> <img src="/pe/2017.2/images/windows/puppetlabs_windows_modulepack.png" alt="Windows Module Pack">
</p>

<p> El paquete Windows "module" incluye mucho "modules" compatibles con Windows que ayudan a realizar las tarea específicas. Usted puede encontrar Windows "modules" buscando en el Forge. Mientras el paquete "module" no está soportado, los "modules" de Puppet contenidos en el paquete son soportados por Puppet Enterprise. El resto han sido evaluados y recomendados por Puppet pero no son seleccionados para el soporte comercial.
</p>

<p> El paquete de Windows "module" activa lo siguiente:
</p>

<ul>
<li>Leer, crear y escribir claves de registro con <a href="https://forge.puppetlabs.com/puppetlabs/registry"><code>registry</code></a>.</li>
  <li>Interactuar con PowerShell a través de Puppet DSL con <a href="https://forge.puppetlabs.com/puppetlabs/powershell"><code>powershell</code></a>.</li>
  <li>Gestionar Windows PowerShell DSC (estado de configuración deseado) utilizando <a href="https://forge.puppetlabs.com/puppetlabs/dsc"><code>dsc</code></a>.</li>
  <li>Reiniciar Windows como parte necesario de la gestión a través <a href="https://forge.puppetlabs.com/puppetlabs/reboot"><code>reboot</code></a>.</li>
  <li>Hacer cumplir los permisos de control de acceso utilizando <a href="https://forge.puppetlabs.com/puppetlabs/acl"><code>acl</code></a>.</li>
  <li>Gestionar las configuraciones del servicio de actualizaciones Windows Server en los clientes nodo <a href="https://forge.puppetlabs.com/puppetlabs/wsus_client"><code>wsus_client</code></a>.</li>
  <li>Instalar o borrar recursos Windows con <a href="https://forge.puppetlabs.com/puppet/windowsfeature"><code>windowsfeature</code></a>.</li>
  <li>Descargue archivos para su uso durante la gestión mediante <a href="https://forge.puppetlabs.com/puppet/download_file"><code>download_file</code></a>.</li>
  <li>Construir sites ISS y aplicaciones virtuales con <a href="https://forge.puppetlabs.com/puppet/iis"><code>iis</code></a>.</li>
  <li>Instalar paquetes con <a href="https://forge.puppetlabs.com/chocolatey/chocolatey"><code>chocolatey</code></a>.</li>
  <li>Gestionar variables de entorno con <a href="https://forge.puppetlabs.com/badgerious/windows_env"><code>windows_env</code></a>.</li>
</ul>
<p> Esta guía cubre la creación de permisos de gestión con <code>ACL</code>, creación de claves de registro y valores con <code>registry</code>, e instalación y creación de sus paqutes con <code>chocolatey</code>.
</p>

<h3 id="prerequisites">Prerequisitos</h3>

<p> Antes de instalar y empezar a trabajar con el paquetes de Windows "modules", usted debería tener  <a href="./install_windows.html">installed Puppet Enterprise</a>.
</p>

<h2 id="install-the-windows-module-pack">Instalar el paquete Windows "module"</h2>

<p> Estos pasos le muestran cómo instalar el paquete "module" localmente, pero también puede instalarlo en Puppet master y pluginsync llevará el paquete "module" a todos sus nodos.
</p>

<ol>
<li>
    <p> Abra el símbolo de sistema de Puppet. Si no ha abierto el CLI antes, entre en  <code>Command Prompt Puppet</code> en su <strong>Menú Inicio</strong>, y pulse click <strong>Start Command Prompt with Puppet</strong>.
</p>
  </li>
  <li>
    <p> Para listar "modules" que actualmente están instalados, escriba <code>puppet module list</code> en su ventana de <strong>Símbolo de sistema</strong>. Si usted acaba de empezar, Es probable que todavía no haya "modules" instalados.
</p>

    <p> <img src="/pe/2017.2/images/windows/cli_list_empty_modules.png" alt="puppet module list empty output">
</p>
  </li>
  <li>
    <p> Siguiente, para instalar el paquete "module" <code>puppetlabs/windows</code>, escriba <code>puppet module install puppetlabs/windows</code>. Tenga en cuenta que obtiene un mensaje de salida de todo lo que está instalado.
</p>

    <pre><code class="language-puppet">C:\&gt;puppet module install puppetlabs/windows
Notice: Preparing to install into
C:/ProgramData/PuppetLabs/code/environments/production/modules ...
Notice: Downloading from https://forgeapi.puppetlabs.com ...
Notice: Installing -- do not interrupt ...
C:/ProgramData/PuppetLabs/code/environments/production/modules
└─┬ puppetlabs-windows (v2.1.0)
├─┬ chocolatey-chocolatey (v1.2.0)
│ └── badgerious-windows_env (v2.2.2)
├── puppet-download_file (v1.2.1)
├── puppet-iis (v1.4.1)
├── puppet-windowsfeature (v1.1.0)
├── puppetlabs-acl (v1.1.1)
├── puppetlabs-powershell (v1.0.5)
├── puppetlabs-reboot (v1.2.0)
├─┬ puppetlabs-registry (v1.1.2)
│ └── puppetlabs-stdlib (v4.9.0)
└── puppetlabs-wsus_client (v1.0.0)
</code></pre>
  </li>
</ol>
<h2 id="task-1-manage-permissions-with-acl">Trabajo 1: Gestionar permisos con <code>acl</code>
</h2>

<p> <img src="/pe/2017.2/images/windows/forge_acl.png" alt="Forge puppetlabs-acl">
</p>

<p> El "module" <a href="https://forge.puppetlabs.com/puppetlabs/acl"><code>puppetlabs-acl</code></a> ayuda a gestionar las listas de control de acceso (ACLs), las cuales proveen una forma de interactuar con los permisos del sistema de ficheros de Windows. Este "module" posibilita llevar tu configuración de permisos básico a unos permisos avanzados utilizando SIDs (Security Identifiers) con una inherente <a href="https://msdn.microsoft.com/en-us/library/aa394063.aspx">access mask</a>, y estrategía de propagación. Lo primero, usted empezará consultando algunos permisos existentes.
</p>

<h3 id="discovery">Descubrimiento</h3>

<p> ACL es una personalización <a href="/puppet/4.10/type.html"></a> y <a href="/puppet/4.10/type.html#providers">proveedor</a>, que puede utilizar <code>las utilidades puppet</code> para buscar ficheros existentes y permisos de carpetas. Para algunos tipos usted puede utilizar el comando <code>puppet resource &lt;TYPE NAME&gt;</code> para obtener todas las instancias de este tipo. De cualquier modo, podría haber miles de ACLs en un sistema Windows, por lo que es mejor especificar la carpeta de cual quiere revisar los tipos. Aquí, revise <code>c:\Usuarios</code> para ver qué permisos contiene.
</p>

<p> En el símbolo de sistema, escriba <code>puppet resource acl c:\Usuarios</code>.
</p>

<p> <img src="/pe/2017.2/images/windows/cli_resource_acl.png" alt="puppet resource acl c:\usuarios output">
</p>

<p> Usted puede limpiar esa salida un poco, de la siguiente manera:
</p>

<pre><code class="language-puppet">acl { 'c:\Usuarios':
  inherit_parent_permissions =&gt; 'false',
  permissions                =&gt; [
   {identity =&gt; 'SYSTEM', rights=&gt; ['full']},
   {identity =&gt; 'Administrators', rights =&gt; ['full']},
   {identity =&gt; 'Users', rights =&gt; ['read', 'execute'], affects =&gt; 'self_only'},
   {identity =&gt; 'Users', rights =&gt; ['read', 'execute'], affects =&gt; 'children_only'},
   {identity =&gt; 'Everyone', rights =&gt; ['read', 'execute'], affects =&gt; 'self_only'},
   {identity =&gt; 'Everyone', rights =&gt; ['read', 'execute'], affects =&gt; 'children_only'}
  ],
}
</code></pre>

<p> Como puede observar, esta carpeta en particular no posee los permisos heredados de su carpeta padre. En cambio, están establecidos sus propios permisos y determina cuántos ficheros hijo y carpetas heredan los permisos establecidos 
</p>

<ul>
<li>
<code>{'identity' =&gt; 'SYSTEM', 'rights'=&gt; ['full']}</code> los estados del usuario “SYSTEM” tendrá acceso total a la carpeta, y por defecto a todas las carpetas hijos, ficheros y carpetas descendientes (como los mismos por defectos cuando son creados los permisos en Windows).</li>
  <li>
<code>{'identity' =&gt; 'Users', 'rights' =&gt; ['read', 'execute'], 'affects' =&gt; 'self_only'}</code> Da permisos de lectura y ejecución a Usuarios, pero sólo en el directorio actual.</li>
  <li>
<code>{'identity' =&gt; 'Everyone', 'rights' =&gt; ['read', 'execute'], 'affects' =&gt; 'children_only'}</code> Da permisos de lectura y ejecución a todos, pero sólo en subcarpetas y archivos.</li>
</ul>
<blockquote>
  <p> <strong>Nota</strong>: Probablemente verá lo que parece ser el mismo permiso para usuario/grupo (ambos “Usuarios” y “Todos” de encima), Donde uno solo afecta a la carpeta y el otro sólo a las carpetas hijo. De hecho, son diferentes permisos.
</p>
</blockquote>

<h3 id="create-a-puppet-managed-permission">Crear permisos de gestión de Puppet</h3>

<ol>
<li>
    <p> Ejecuta este código para crear tu primer permiso de gestión de Puppet. Entonces, guardalo como <code>perms.pp</code>.
</p>

    <pre><code class="language-puppet">file{'c:/tempperms':
 ensure =&gt; directory,
}

# Por defecto, el acl creará una relación implícita con cualquier
# recurso que se puede encontrar en la localización.
acl {'c:/tempperms':
 permissions =&gt; [
   {identity =&gt; 'Administradores', rights =&gt; ['full']},
   {identity =&gt; 'Usuarios', rights =&gt; ['read','execute']}
 ],
}
</code></pre>

    <p> <img src="/pe/2017.2/images/windows/perms_pp_manifest.png" alt="perms.pp file">
</p>
  </li>
  <li>
    <p> Para validar tu manifiesto, en el símbolo de sistema, escribe <code>puppet parser validate c:\path\to\perms.pp</code>. El comando parser no devuelve nada, esto significa que ha pasado la validación.
</p>

    <p> <img src="/pe/2017.2/images/windows/cli_parser_validate.png" alt="puppet parser validate no issues">
</p>
  </li>
  <li>
    <p> Para aplicar el manifiesto, escribe <code>puppet apply c:\path\to\perms.pp</code>. Tu salida debería ser similar la salida de abajo.
</p>

    <pre><code class="language-powershell">Notice: Compiled catalog for win2012r2x64 in environment production in 0.12 seconds
Notice: /Stage[main]/Main/File[c:/tempperms]/ensure: created
Notice: /Stage[main]/Main/Acl[c:/tempperms]/permissions: permissions changed [
] to [
 { identity =&gt; 'BUILTIN\Administrators', rights =&gt; ["full"] },
 { identity =&gt; 'BUILTIN\Users', rights =&gt; ["read", "execute"] }
]
Notice: Applied catalog in 0.05 seconds
</code></pre>
  </li>
  <li>
    <p> Revisa los permisos en su Windows UI. En <strong>Windows Explorer</strong>, click con el botón derecho <strong>tempperms</strong> y click  sobre <strong>Propiedades</strong>. Entonces, click sobre la etiqueta <strong>Security</strong>. Debería ser similar a la imagen de abajo.
</p>

    <p> <img src="/pe/2017.2/images/windows/security_properties.png" alt="Security properties of c:\tempperms">
</p>
  </li>
  <li>
    <p> Opcional: Podría parecer que tienes más permisos de los que esperabas aquí. Esto es porque por defecto Windows hereda los permisos padre. En este caso, es posible que no quiera hacerlo. Ajustar el recurso <code>acl</code> para no heredar los permisos padre cambiando el fichero <code>perms.pp</code> para que parezca lo siguiente añadiendo <code>inherit_parent_permissions =&gt; false</code>.
</p>

    <pre><code class="language-puppet">acl {'c:/tempperms':
  inherit_parent_permissions =&gt; false,
  permissions                =&gt; [
    {identity =&gt; 'Administradores', rights =&gt; ['full']},
    {identity =&gt; 'Usuarios', rights =&gt; ['read','execute']}
  ],
}
</code></pre>
  </li>
  <li>
    <p> Guarda el fichero, y vuelve de nuevo al símbolo de sistema <code>puppet parser validate c:\path\to\perms.pp</code>.
</p>
  </li>
  <li>
    <p> Cuando valide, ejecute <code>puppet apply c:\path\to\perms.pp</code>.
</p>

    <p> El resultado debería ser similar al siguiente:
</p>

    <pre><code class="language-powershell">C:\&gt;puppet apply c:\puppet_code\perms.pp
Notice: Compiled catalog for win2012r2x64 in environment production in 0.08 seconds
Notice: /Stage[main]/Main/Acl[c:/tempperms]/inherit_parent_permissions: inherit_
parent_permissions changed 'true' to 'false'
Notice: Applied catalog in 0.02 seconds
</code></pre>
  </li>
  <li>
    <p> Para aplicar los permisos, escribe <code>icacls c:\tempperms</code>. El comando, <code>icacls</code>, esta específicamente para desplegar y modificar ACLs. La salida debería ser similar a lo siguiente:
</p>

    <pre><code class="language-powershell">C:\&gt;icacls c:\tempperms
c:\tempperms BUILTIN\Administradores:(OI)(CI)(F)
             BUILTIN\Users:(OI)(CI)(RX)
             NT AUTHORITY\SYSTEM:(OI)(CI)(F)
             BUILTIN\Users:(CI)(AD)
             CREATOR OWNER:(OI)(CI)(IO)(F)
Successfully processed 1 files; Failed processing 0 files
</code></pre>

    <p> La salida muestra cada permiso, seguido por una lista de derechos específicos entre paréntesis. Esta salida muestra que hay más permisos que los especificados en <code>perms.pp</code>. Puppet administrará los permisos de manera sencilla junto a los permisos existentes o no administrados. En el caso de eliminar la herencia, por defecto Windows copia los permisos heredados existentes (o Entradas de acceso de control, ACE) sobre la existente ACL para que tenga más permisos que los que deseaba.
</p>
  </li>
  <li>
    <p> Borre los permisos extra, de modo que sólo los permisos que haya especificado estén en la carpeta. Para hacer esto, en su <code>perms.pp</code> establezca <code>purge =&gt; true</code> como sigue:
</p>

    <pre><code class="language-puppet">acl {'c:/tempperms':
  inherit_parent_permissions =&gt; false,
  purge                      =&gt; true,
  permissions                =&gt; [
    {identity =&gt; 'Administradores', rights =&gt; ['full']},
    {identity =&gt; 'Usuarios', rights =&gt; ['read','execute']}
  ],
}
</code></pre>
  </li>
  <li>
    <p> Ejecuta el comando parser como hemos visto antes. Si todavía no devuelve errores, puede aplicar el cambio.
</p>
  </li>
  <li>
    <p> Para aplicar cambios, escribir <code>puppet apply c:\path\to\perms.pp</code>. Tu salida debería ser similar a:
</p>

    <pre><code class="language-powershell">C:\&gt;puppet apply c:\puppet_code\perms.pp
Notice: Compiled catalog for win2012r2x64 in environment production in 0.08 seco
nds
Notice: /Stage[main]/Main/Acl[c:/tempperms]/permissions: permissions changed [
{ identity =&gt; 'BUILTIN\Administradores', rights =&gt; ["full"] },
{ identity =&gt; 'BUILTIN\Usuarioss', rights =&gt; ["read", "execute"] },
{ identity =&gt; 'NT AUTHORITY\SYSTEM', rights =&gt; ["full"] },
{ identity =&gt; 'BUILTIN\Users', rights =&gt; ["mask_specific"], mask =&gt; '4', child_types =&gt; 'containers' },
{ identity =&gt; 'CREATOR OWNER', rights =&gt; ["full"], affects =&gt; 'children_only' }
] to [
{ identity =&gt; 'BUILTIN\Administrators', rights =&gt; ["full"] },
{ identity =&gt; 'BUILTIN\Users', rights =&gt; ["read", "execute"] }
]
Notice: Applied catalog in 0.05 seconds
</code></pre>

    <p> Puppet genera un aviso, ya que está eliminando cada uno de los permisos.
</p>
  </li>
  <li>
    <p> Revisa la salida de <code>icacls</code> una vez más. Escribiendo <code>icacls c:\tempperms</code>.
</p>

    <pre><code class="language-powershell">c:\&gt;icacls c:\tempperms
c:\tempperms BUILTIN\Administradores:(OI)(CI)(F)
            BUILTIN\Usuarios:(OI)(CI)(RX)
Successfully processed 1 files; Failed processing 0 files
</code></pre>

    <p> Los permisos para este directorio han sido establecidos. Puedes obtener más escenarios de permisos avanzados si lee el <a href="https://forge.puppetlabs.com/puppetlabs/acl#usage">uso de escenarios</a> en el modulo de  Puppet Forge. También puedes leer en profuncidad en la<a href="https://puppetlabs.com/blog/managing-permissions-windows-access-control-lists"> entrada del blog sobre ACLs</a> en el blog de Puppet.
</p>
  </li>
</ol>
<h2 id="task-2-create-puppet-managed-registry-keys-with-registry">Trabajo 2: Crear claves de registro gestionadas  Puppet con <code>registry</code>
</h2>

<p> <img src="/pe/2017.2/images/windows/forge_registry.png" alt="Forge puppetlabs-registry">
</p>

<p> Eventualmente, es probable que tenga que utilizar el registro para acceder y establecer configuraciones de alta disponibilidad, entre otras cosas. El module <a href="https://forge.puppetlabs.com/puppetlabs/registry">puppetlabs-registry</a> , el cual también es <a href="https://forge.puppetlabs.com/supported">Puppet Supported Module</a> le permite establecer tanto las claves del registro como los valores.
</p>

<h3 id="discovery-1">Descubrimiento</h3>

<p> <code>puppetlabs-registry</code> es una configuración <a href="/puppet/4.10/type.html">type</a> y <a href="/puppet/4.10/type.html#providers">provider</a>, por lo que puedes utilizar <code>puppet resource</code>para revisar la configuración registros existente. También es algo limitado, como el module <code>acl</code> en que se limita a lo que se especifica. Seleccione <code>HKLM\Software\Microsoft\Windows</code> y vea lo que puede obtener.
</p>

<p> Escriba <code>puppet resource registry_key 'HKLM\Software\Microsoft\Windows'</code>.
</p>

<p> <img src="/pe/2017.2/images/windows/cli_resource_registry.png" alt="Output of puppet resource registry_key 'HKLM\Software\Microsoft\Windows'">
</p>

<p> No es interesante, pero ahora eche un vistazo a un valor de registro.
</p>

<p> Escriba <code>puppet resource registry_value 'HKLM\SYSTEM\CurrentControlSet\Services\BITS\DisplayName'</code>:
</p>

<pre><code class="language-puppet">registry_value { 'HKLM\SYSTEM\CurrentControlSet\Services\BITS\DisplayName':
  ensure =&gt; 'present',
  data   =&gt; ['Background Intelligent Transfer Service'],
  type   =&gt; 'string',
}
</code></pre>

<p> Esto es un poco más interesante que una clave del registro. Las claves son como path de ficheros (directorios) y los valores son como fichero que contienen datos y pueden ser de <a href="https://forge.puppetlabs.com/puppetlabs/registry#parameters">diferentes tipos</a>.
</p>

<h3 id="exercise">Ejercicio</h3>

<ol>
<li>
    <p> Crea tus primeros claves y valores del registro gestionados por Puppet:
</p>

    <pre><code class="language-puppet">registry_key { 'HKLM\Software\zTemporaryPuppet':
     ensure =&gt; present,
}

# Por defecto el registro crea una relación implícita a cualquier fichero
# los recursos encuentran esta localización.
registry_value {'HKLM\Software\zTemporaryPuppet\StringValue':
  ensure =&gt; 'present',
  data   =&gt; 'This is a custom value.',
  type   =&gt; 'string',
}

#forzar una vista del registro de  32-bit,  revisa donde se creo:
registry_key { '32:HKLM\Software\zTemporaryPuppet':
  ensure =&gt; present,
}

registry_value {'32:HKLM\Software\zTemporaryPuppet\StringValue':
  ensure =&gt; 'present',
  data   =&gt; 'This is a custom 32-bit value.',
  type   =&gt; 'expand',
}
</code></pre>
  </li>
  <li>
    <p> Guarda el fichero como <code>registry.pp</code>.
</p>
  </li>
  <li>
    <p> Valida el manifiesto. En el símbolo de sistema, escribe <code>puppet parser validate c:\path\to\registry.pp</code>. El comando parser no devuelve nada, esto significa que ha pasado la validación.
</p>
  </li>
  <li>
    <p> Ahora, aplica el manifest escribiendo <code>puppet apply c:\path\to\registry.pp</code>. Tu salida puede ser similar a la de abajo.
</p>

    <pre><code class="language-powershell">Notice: Compiled catalog for win2012r2x64 in environment production in 0.11 seco
nds
Notice: /Stage[main]/Main/Registry_key[HKLM\Software\zTemporaryPuppet]/ensure: c
reated
Notice: /Stage[main]/Main/Registry_value[HKLM\Software\zTemporaryPuppet\StringVa
lue]/ensure: created
Notice: /Stage[main]/Main/Registry_key[32:HKLM\Software\zTemporaryPuppet]/ensure
: created
Notice: /Stage[main]/Main/Registry_value[32:HKLM\Software\zTemporaryPuppet\Strin
gValue]/ensure: created
Notice: Applied catalog in 0.03 seconds
</code></pre>
  </li>
  <li>
    <p> A continuación, inspeccione el registro y ver lo que contiene. Pulse <strong>Inicio + R</strong>, entonces escriba <code>regedit</code> y pulse  <strong>Enter</strong>. Una vez ha abierto el Editos de Registro, encuentre su clave bajo  <code>HKEY_LOCAL_MACHINE</code>.
</p>

    <p> <img src="/pe/2017.2/images/windows/regedit_HKLM.png" alt="Registry Editor display of keys">
</p>

    <p> Fijese que la clave de  32-bit fue creada bajo la sección 32-bit de Software para  Wow6432Node.
</p>
  </li>
  <li>
    <p> Aplique el manifiesto escribiendo de nuevo <code>puppet apply c:\path\to\registry.pp</code>.
</p>

    <pre><code class="language-powershell">Notice: Compiled catalog for win2012r2x64 in environment production in 0.11 seconds
Notice: Applied catalog in 0.02 seconds
</code></pre>
  </li>
  <li>
    <p> Nada cambió, así que no hay trabajo para hacer Puppet. En el <strong>Editor de Registro</strong>, modifique el dato. Seleccione <code>HKLM\Sofware\zTemporaryPuppet</code> y en la parte derecha, doble-click sobre <code>StringValue</code>. Modifique el valor data, y  seleccione <strong>OK</strong>.
</p>

    <p> <img src="/pe/2017.2/images/windows/regedit_edit_value.png" alt="Edit StringValue of HKLM\Sofware\zTemporaryPuppet">
</p>

    <p> Esta vez, se han realizado cambios, por lo que escribiendo <code>puppet apply c:\path\to\registry.pp</code> muestra una salida diferente.
</p>

    <pre><code class="language-powershell">Notice: Compiled catalog for win2012r2x64 in environment production
in 0.11 seconds
Notice: /Stage[main]/Main/Registry_value[HKLM\Software\zTemporaryPuppet\StringValue]/data:
data changed 'This is a custom value. Edited' to 'This is a custom value.'
Notice: Applied catalog in 0.03 seconds
</code></pre>

    <p> Corrige automáticamente la desviación de la configuración.
</p>
  </li>
  <li>
    <p> Siguiente paso, borrar y eliminar las claves y valores Modifique su fichero <code>registry.pp</code> a imagen del de abajo:
</p>

    <pre><code class="language-puppet">registry_key { 'HKLM\Software\zTemporaryPuppet':
  ensure =&gt; absent,
}

#forcing a 32 bit registry view, watch where this is created
registry_key { '32:HKLM\Software\zTemporaryPuppet':
  ensure =&gt; absent,
}
</code></pre>
  </li>
  <li>
    <p> Validar con <code>puppet parser validate c:\path\to\registry.pp</code> y aplicarlo de nuevo con <code>puppet apply c:\path\to\registry.pp</code>.
</p>

    <pre><code class="language-powershell">Notice: Compiled catalog for win2012r2x64 in environment production in 0.06 seconds
Notice: /Stage[main]/Main/Registry_key[HKLM\Software\zTemporaryPuppet]/ensure: removed
Notice: /Stage[main]/Main/Registry_key[32:HKLM\Software\zTemporaryPuppet]/ensure
: removed
Notice: Applied catalog in 0.02 seconds
</code></pre>

    <p> Refresque la vista en su Editor de Registro Los valores han desaparecido.
</p>

    <p> <img src="/pe/2017.2/images/windows/regedit_absent.png" alt="Removed items verification in Registry Editor">
</p>
  </li>
</ol>
<h3 id="real-world-usage">Uso en el mundo real</h3>

<p> Este es un ejemplo del mundo real que deshabilita el informe de errores:
</p>

<pre><code class="language-puppet">class puppetconf::disable_error_reporting {
  registry_value { 'HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\Windows Error Reporting\ForceQueue':
    type =&gt; dword,
    data =&gt; '1',
  }

  registry_value { 'HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\Windows Error Reporting\DontShowUI':
    type =&gt; dword,
    data =&gt; '1',
  }

  registry_value { 'HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\Windows Error Reporting\DontSendAdditionalData':
    type =&gt; dword,
    data =&gt; '1',
  }

  registry_key { 'HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\Windows Error Reporting\Consent':
    ensure       =&gt; present,
  }

  registry_value { 'HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\Windows Error Reporting\Consent\DefaultConsent':
   type =&gt; dword,
   data =&gt; '2',
  }
}
</code></pre>

<h3 id="want-more-info-about-the-registry-module">¿Desea más información sobre el module registro?</h3>

<p> Lea la entrada del blog sobre <a href="https://puppetlabs.com/blog/re-introducing-puppetlabs-registry-module">La reintroducción del module de registro</a>, <a href="https://puppetlabs.com/blog/puppet-works-on-windows">“¿Trabaja Puppet sobre Windows?” post</a>, ve la presentación <a href="https://puppetlabs.com/presentations/getting-started-puppet-windows-josh-cooper-puppet-labs">“Getting Started with Puppet on Windows”</a>  del PuppetConf 2014 realizada por Josh Cooper, y <a href="https://puppetlabs.com/presentations/workshop-puppet-windows-users-ethan-brown-puppet-labs">“Workshop: Puppet for Windows Users”</a> realizada por Ethan Brown celebrada en el PuppetConf 2014. Usted también puede consultar referencias y ejemplos en la documentación de module en  el <a href="https://forge.puppetlabs.com/puppetlabs/registry/readme">Forge</a>.
</p>

<h2 id="task-3-create-install-and-repackage-packages-with-chocolatey">Trabajo 3: Crear, instalar and re-empaquetar con <code>chocolatey</code>
</h2>

<p> <img src="/pe/2017.2/images/windows/forge_chocolatey.png" alt="Forge chocolatey-chocolatey">
</p>

<p> <a href="https://chocolatey.org">Chocolatey</a> es un gestor de paquetes para Windows que es similar en diseño y ejecución a administradores de paquetes en sistemas que no son de Windows. El <a href="https://forge.puppetlabs.com/chocolatey/chocolatey">chocolatey module</a> es un <a href="https://forge.puppetlabs.com/approved">Puppet Approved Module</a>, por lo que no es elegible para los servicios de soporte de Puppet Enterprise. El module tiene la capacidad de configurar e instalar Chocolatey y gestionar el software de Windows con paquetes Chocolatey.
</p>

<h3 id="discovery-2">Descubrimiento</h3>

<p> Chocolatey tiene un provider personalizado para el paquete tipo type, por lo que puedes utilizar <code>puppet resource</code> para consultar los paquetes existentes.
</p>

<p> Escribe <code>puppet resource package --param provider | more</code>. El parámetro adicional provider en la salida de este comando reproduce todos los tipos de paquetes instalados que son detectados por varios providers.
</p>

<h3 id="install-chocolatey">Cómo instalar Chocolatey</h3>

<p> Vas a instalar Chocolatey (choco.exe). Puede hacerlo siguiendo las instrucciones de <a href="https://chocolatey.org">Página Inicio Chocolatey</a>, o puede utilizar el módulo para asegurarse de que está instalado Chocolatey.
</p>

<ol>
<li>
    <p> Cree un nuevo manifest en el module <code>chocolatey</code> denominado <code>chocolatey.pp</code> con el siguiente contenido:
</p>

    <pre><code class="language-puppet">include chocolatey
</code></pre>
  </li>
  <li>
    <p> Validar el manifiesto escribiendo <code>puppet parser validate c:\path\to\chocolatey.pp</code>en la ventana de símbolo de sistema. El comando parser no devuelve nada, esto significa que ha pasado la validación.
</p>
  </li>
  <li>
    <p> Ahora aplique el manifest con  <code>puppet apply c:\path\to\chocolatey.pp</code>. La salida debería ser similar a la siguiente.
</p>

    <pre><code class="language-powershell">Notice: Compiled catalog for win2012r2x64 in environment production in 0.58 seconds
Notice: /Stage[main]/Chocolatey::Install/Windows_env[chocolatey_PATH_env]/ensure
: created
Notice: /Stage[main]/Chocolatey::Install/Windows_env[chocolatey_ChocolateyInstal
l_env]/ensure: created
Notice: /Stage[main]/Chocolatey::Install/Exec[install_chocolatey_official]/retur
ns: executed successfully
Notice: /Stage[main]/Chocolatey::Install/Exec[install_chocolatey_official]: Trig
gered 'refresh' from 2 events
Notice: Finished catalog run in 13.22 seconds
</code></pre>

    <p> En un escenario de producción, es probable que tenga un fichero  Chocolatey.nupkg en alguna parte interna. En casos como este, puedes utilizar el <a href="https://forge.puppetlabs.com/chocolatey/chocolatey#use-an-internal-chocolateynupkg-for-chocolatey-installation">nupkg interno para instalaciones Chocolatey</a>:
</p>

    <pre><code class="language-puppet">class {'chocolatey':
  chocolatey_download_url =&gt; 'https://internalurl/to/chocolatey.nupkg',
  use_7zip                =&gt; false,
  log_output              =&gt; true,
}
</code></pre>
  </li>
</ol>
<h3 id="install-a-package">Cómo instalar un paquete</h3>

<p> Normalmente, cuando instalamos paquetes, primero los copiamos internamente, realizamos cualquier cambio requerido para llevar todo lo que descargan a una ubicación interna, empaquetamos el paquete con las modificaciones, y/o construir sus propios paquetes para alojar en su repositorio de paquetes interno (feed). De todos modos, para este ejercicio, however, puedes instalar directamente la versión portable de  Notepad++ de Chocolatey’s <a href="https://chocolatey.org/packages">community feed</a>. El paquete <a href="https://chocolatey.org/packages/notepadplusplus.commandline">Notepad++ Commandline</a> es portable y no deberia tener una gran impacto sobre sistema existente.
</p>

<ol>
<li>
    <p> Actualiza el manifest (<code>chocolatey.pp</code>) con el siguiente contenido:
</p>

    <pre><code class="language-puppet">package {'notepadplusplus.commandline':
  ensure   =&gt; installed,
  provider =&gt; chocolatey,
}
</code></pre>
  </li>
  <li>
    <p> Validar el manifiesto escribiendo <code>puppet parser validate c:\path\to\chocolatey.pp</code>en la ventana de símbolo de sistema. El comando parser no devuelve nada, esto significa que ha pasado la validación.
</p>
  </li>
  <li>
    <p> Ahora, aplica el manifiesto con <code>puppet apply c:\path\to\chocolatey.pp</code>. Su salida debería ser similar a lo siguiente.
</p>

    <pre><code>Notice: Compiled catalog for win2012r2x64 in environment production in 0.75 seconds
Notice: /Stage[main]/Main/Package[notepadplusplus.commandline]/ensure: created
Notice: Applied catalog in 15.51 seconds
</code></pre>

    <p> Si quieres utilizar este paquete en un escenario de producción, necesitas un feed interno personalizado. Esto es sencillo de configurar con el module <a href="https://forge.puppetlabs.com/chocolatey/chocolatey_server"><code>chocolatey_server</code></a>. También puedes utilizar Sonatype Nexus, Artifactory, o compartir por medio de CIFS Si desea alojar paquetes con una opción que no sea de Windows, O puede utilizar cualquier cosa en Windows que exponga un NuGet OData feed (Nuget es la estructura de empaquetado que utiliza Chocolatey). Consulta la página<a href="https://github.com/chocolatey/choco/wiki/How-To-Host-Feed">Cómo alojar un Feed</a> del wiki de <code>chocolatey</code> para una información en profundidad. También podrías guardar paquetes en Puppet master y usar un fichero de recursos para verificar que ellos están en directorio prioritario local específico asegurando los paquetes.
</p>
  </li>
</ol>
<h4 id="copy-an-existing-package-and-make-it-internal-repackaging-packages">Copia un paquete existente y hazlo interno (empaquetando paquetes)</h4>

<p> Chocolatey’s <a href="https://chocolatey.org/packages">es un feed de la comunidad</a> Tiene bastantes paquetes, pero están orientados hacia la comunidad y el uso de Internet para la descarga de los sitios de distribución oficial. Sin embargo, son atractivos, ya que tienen todo lo necesario para instalar software en su máquina. A través del proceso de empaquetado, mediante el cual usted toma un paquete comunitario y trae todos los bits internos y/o embebidos en el paquete, Puede internalizar completamente un paquete para alojar en un repositorio Chocolatey/NuGet interno. Esto le da un control completo sobre un paquete y elimina los problemas de control y confianza de producción antes mencionados.
</p>

<p> Para hacer que el paquete existente sea local, siga estos pasos.
</p>

<ol>
<li>
    <p> Descarga el paquete desde el feed de Comunidad de Chocolatey desde  <a href="https://chocolatey.org/packages/notepadplusplus.commandline">página del paquete</a> y haciendo click en el link de descarga.
</p>

    <p> <img src="/pe/2017.2/images/windows/choco_npp_download.png" alt="Download Link">
</p>
  </li>
  <li>
    <p> Renombra el fichero el final del fichero descargado con <code>.zip</code> y desempaqueta el fichero como un archivo normal.
</p>

    <p> <img src="/pe/2017.2/images/windows/choco_rename_nupkg_zip.png" alt="Rename to append .zip suffix">
</p>
  </li>
  <li>
    <p> Borra las carpetas <code>_rels</code> y <code>package</code> y el archivo <code>[Content_Types].xml</code>. Estos son creados durante el <code>choco pack</code> y debería no estar incluidos,  ya que serán regenerados (y su existencia conduce a problemas).
</p>

    <p> <img src="/pe/2017.2/images/windows/choco_delete_pkg_files.png" alt="Remove _rels, package, and the xml file">
</p>
  </li>
  <li>
    <p> Siguiente paso, abrir <code>tools\chocolateyInstall.ps1</code>.
</p>

    <pre><code class="language-powershell">Install-ChocolateyZipPackage 'notepadplusplus.commandline' 'https://notepad-plus-plus.org/repository/6.x/6.8.7/npp.6.8.7.bin.zip' "$(Split-Path -parent $MyInvocation.MyCommand.Definition)"
</code></pre>
  </li>
  <li>
    <p> Descargue el archivo zip y colóquelo en la carpeta tools del paquete.
</p>

    <p> <img src="/pe/2017.2/images/windows/choco_download_zip.png" alt="Zip file embedding in package">
</p>
  </li>
  <li>
    <p> Siguiente, editar <code>chocolateyInstall.ps1</code> para apuntar a este fichero embebido en lugar de ir a internet (Si el tamaño del fichero supera los 50MB, Es posible que desee ponerlo en un archivo compartido en algún lugar de forma interna para un mejor rendimiento).
</p>

    <pre><code class="language-powershell">$toolsDir   = "$(Split-Path -parent $MyInvocation.MyCommand.Definition)"
Install-ChocolateyZipPackage 'notepadplusplus.commandline' "$toolsDir\npp.6.8.7.bin.zip" "$toolsDir"
</code></pre>

    <p> Las comillas dobles permiten la interpolación de cadenas (lo que significa que las variables se interpretan en lugar de tomadas literalmente).
</p>
  </li>
  <li>
    <p> Siguiente, abrir el fichero <code>*.nuspec</code> para ver su contenido y realizar los cambios necesarios.
</p>

    <pre><code class="language-xml">&lt;?xml version="1.0"?&gt;
&lt;package xmlns="http://schemas.microsoft.com/packaging/2010/07/nuspec.xsd"&gt;
  &lt;metadata&gt;
    &lt;id&gt;notepadplusplus.commandline&lt;/id&gt;
    &lt;version&gt;6.8.7&lt;/version&gt;
    &lt;title&gt;Notepad++ (Portable, CommandLine)&lt;/title&gt;
    &lt;authors&gt;Don Ho&lt;/authors&gt;
    &lt;owners&gt;Rob Reynolds&lt;/owners&gt;
    &lt;projectUrl&gt;https://notepad-plus-plus.org/&lt;/projectUrl&gt;
    &lt;iconUrl&gt;https://cdn.rawgit.com/ferventcoder/chocolatey-packages/02c21bebe5abb495a56747cbb9b4b5415c933fc0/icons/notepadplusplus.png&lt;/iconUrl&gt;
    &lt;requireLicenseAcceptance&gt;false&lt;/requireLicenseAcceptance&gt;
    &lt;description&gt;Notepad++ is a ... &lt;/description&gt;
    &lt;summary&gt;Notepad++ is a free (as in "free speech" and also as in "free beer") source code editor and Notepad replacement that supports several languages. &lt;/summary&gt;
    &lt;tags&gt;notepad notepadplusplus notepad-plus-plus&lt;/tags&gt;
  &lt;/metadata&gt;
&lt;/package&gt;
</code></pre>

    <p> Algunas organizaciones cambiarán el campo de versión para indicar que se trata de un paquete interno editado, por ejemplo, cambiar <code>6.8.7</code> to <code>6.8.7.20151202</code>. Por ahora, esto no es necesario.
</p>

    <p> Ahora puedes navegar por medio de la línea de comando a las carpeta con el fichero <code>.nuspec</code> (Desde una máquina Windows, a menos que haya instalado Mono y construido choco.exe desde el source) y utilizar <code>choco pack</code>. Puedes ser más específico y escribir <code>choco pack path\to\notepadplusplus.commandline.nuspec</code>. La salida debe ser similar a la siguiente.
</p>

    <pre><code>Intentando construir el paquete desde 'notepadplusplus.commandline.nuspec'.
Paquete creado con éxito 'notepadplusplus.commandline.6.8.7.nupkg'
</code></pre>

    <p> Normalmente se prueba en un sistema para asegurarse de que el paquete que acaba de construir es bueno antes de enviar el paquete (Solo el * .nupkg) a su repositorio interno. Esto puede realizarlo utilizando <code>choco.exe</code> en un sistema de prueba. Para instalar (<code>choco install notepadplusplus.commandline -source %cd%</code> - change <code>%cd%</code> to <code>$pwd</code> in PowerShell.exe) y para desinstalar (<code>choco uninstall notepadplusplus.commandline</code>). Otro método de prueba es ejecutar el manifiest apuntado a una carpeta de origen local, que es lo que vas a hacer.
</p>
  </li>
  <li>
    <p> Cree <code>c:\packages</code> y copie el archivo de paquete resultante (<code>notepadplusplus.commandline.6.8.7.nupkg</code>).
</p>

    <p> <img src="/pe/2017.2/images/windows/choco_local_packages.png" alt="package in folder">
</p>

    <p> Esto no se instalará realmente en este sistema ya que acaba de instalar la misma versión del feed de la comunidad de Chocolatey. Por lo tanto, necesita quitar primero el paquete existente. Para borrarlo, edite <code>chocolatey.pp</code> para establecer el paquete a eliminar.
</p>

    <pre><code class="language-puppet">package {'notepadplusplus.commandline':
  ensure   =&gt; absent,
  provider =&gt; chocolatey,
}
</code></pre>
  </li>
  <li>
    <p> Validar el manifiesto con <code>puppet parser validate path\to\chocolatey.pp</code>. Aplica el manifest para asegurar el cambio <code>puppet apply c:\path\to\chocolatey.pp</code>.
</p>

    <pre><code class="language-powershell">Notice: Compiled catalog for win2012r2x64 in environment production in 1.03 seconds
Notice: /Stage[main]/Main/Package[notepadplusplus.commandline]/ensure: removed
Notice: Applied catalog in 12.20 seconds
</code></pre>

    <p> Puede confirmar que el paquete ha sido eliminado, por medio del cheque de la localización de la instalación del paquete o utilizando <code>choco list -lo</code>.
</p>

    <p> <img src="/pe/2017.2/images/windows/choco_list_local.png" alt="Package is uninstalled">
</p>
  </li>
  <li>
    <p> Actualizar el manifest (<code>chocolatey.pp</code>) para utilizar el paquete personalizado.
</p>

    <pre><code class="language-puppet">package {'notepadplusplus.commandline':
  ensure   =&gt; latest,
 provider =&gt; chocolatey,
 source   =&gt; 'c:\packages',
}
</code></pre>
  </li>
  <li>
    <p> Validar el manifiesto con el parser y aplicarlo de nuevo. Usted verá a Puppet creando la nueva instalación en la salida del comando.
</p>

    <pre><code>Notice: Compiled catalog for win2012r2x64 in environment production in 0.79 seconds
Notice: /Stage[main]/Main/Package[notepadplusplus.commandline]/ensure: created
Notice: Applied catalog in 14.78 seconds
</code></pre>
  </li>
  <li>
    <p> En un paso anterior, usted agregó un fichero <code>*.zip</code> al paquete, por lo que usted puede inspeccionar y asegurarse que el paquete personalizado está instalado. Dirígete a  <code>C:\ProgramData\chocolatey\lib\notepadplusplus.commandline\tools</code> (Si tienes la localización de la instalación por defecto para Chocolatey) y consulta si puedes encontrar el fichero <code>*.zip</code>.
</p>
  </li>
</ol>
<p> <img src="/pe/2017.2/images/windows/choco_list_local_installed.png" alt="Package is installed">
</p>

<p> También puede validar <code>chocolateyInstall.ps1</code> abriendo y consultando que el fichero personalizado ha cambiado. 
</p>

<h4 id="create-a-package">Crea un paquete</h4>

<p> Crear paquetes propios es, para algunos administradores de sistemas, sorprendentemente simple comparado con otros estándares de empaquetado.
</p>

<p> Asegúrese de tener por lo menos Chocolatey CLI (choco.exe) versión <code>0.9.9.11</code> o mayor para lasiguiente parte.
</p>

<ol>
<li>
    <p> Desde el símbolo de sistema, escribir <code>choco new -h</code> para visualizar el menú de ayuda con las opciones disponibles.
</p>
  </li>
  <li>
    <p> Siguiente, utiliza <code>choco new vagrant</code> para crear un paquete denominado ‘vagrant’. La salida debería ser similar a:
</p>

    <pre><code>Creating a new package specification at C:\temppackages\vagrant
Generating template to a file
 at 'C:\temppackages\vagrant\vagrant.nuspec'
Generating template to a file
 at 'C:\temppackages\vagrant\tools\chocolateyinstall.ps1'
Generating template to a file
 at 'C:\temppackages\vagrant\tools\chocolateyuninstall.ps1'
Generating template to a file
 at 'C:\temppackages\vagrant\tools\ReadMe.md'
Successfully generated vagrant package specification files
 at 'C:\temppackages\vagrant'
</code></pre>

    <p> Viene con algunos plantillas para que usted rellene ( usted también puede crear sus propias plantillas para utilizarlas más adelante).
</p>
  </li>
  <li>
    <p> Abra <code>vagrant.nuspec</code>, y editelo para que tenga un aspecto similar a:
</p>

    <pre><code class="language-xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;package xmlns="http://schemas.microsoft.com/packaging/2015/06/nuspec.xsd"&gt;
  &lt;metadata&gt;
    &lt;id&gt;vagrant&lt;/id&gt;
    &lt;title&gt;Vagrant (Install)&lt;/title&gt;
    &lt;version&gt;1.8.4&lt;/version&gt;
    &lt;authors&gt;HashiCorp&lt;/authors&gt;
    &lt;owners&gt;my company&lt;/owners&gt;
    &lt;description&gt;Vagrant - Development environments made easy.&lt;/description&gt;
  &lt;/metadata&gt;
  &lt;files&gt;
    &lt;file src="tools\**" target="tools" /&gt;
  &lt;/files&gt;
&lt;/package&gt;
</code></pre>

    <p> A menos que esté compartiendo, usted no necesita la mayor parte de lo que está en el archivo de plantilla nuspec, por lo que sólo los elementos necesarios se incluyen arriba. Lo importante que debe hacer al crear un paquete es que coincida con la versión del paquete del archivo nusepec con la versión del software subyacente lo más posible. Usted dispondrá la versión más reciente de Vagrant dentro del paquete creado, por lo que la versión del paquete en el fichero nuspec coincidirá. En esta versión, Vagrant 1.8.4 está siendo empaquetado. <a href="https://github.com/chocolatey/choco/wiki/CreatePackages#versioning-recommendations">Más sobre versiones</a>.
</p>
  </li>
  <li>
    <p> Abre <code>chocolateyInstall.ps1</code> y editalo para que tenga el siguiente aspecto:
</p>

    <pre><code class="language-powershell">$ErrorActionPreference = 'Stop';

$packageName= 'vagrant'
$toolsDir   = "$(Split-Path -parent $MyInvocation.MyCommand.Definition)"
$fileLocation = Join-Path $toolsDir 'vagrant_1.8.4.msi'

$packageArgs = @{
  packageName   = $packageName
  fileType      = 'msi'
  file         = $fileLocation

  silentArgs    = "/qn /norestart"
  validExitCodes= @(0, 3010, 1641)
}

Install-ChocolateyInstallPackage @packageArgs
</code></pre>

    <blockquote>
      <p> <strong>Nota</strong>: Lo anterior es <a href="https://github.com/chocolatey/choco/wiki/HelpersInstallChocolateyInstallPackage"><code>Install-ChocolateyINSTALLPackage</code></a>, no confundir con <a href="https://github.com/chocolatey/choco/wiki/HelpersInstallChocolateyPackage"><code>Install-ChocolateyPackage</code></a>. Los nombres son muy parecidos unos con otro, de todas formas este último también descargará software  de una URI (URL, ftp, fichero), la cual no es necesaria para este ejemplo.
</p>
    </blockquote>
  </li>
  <li>
    <p> Elimine los ficheros <code>ReadMe.md</code> u <code>chocolateyUninstall.ps1</code>. <a href="https://www.vagrantup.com/downloads.html">Descargue Vagrant</a> y muevalo a la carpeta tools del paquete.
</p>

    <blockquote>
      <p> <strong>Nota</strong>: Normalmente si el paquete supera los 100MB, es recomendable mover el software de instalación/archivo a una carpeta compartida o en su lugar, apuntarla a ella.  Para este ejemplo, lo agrupará como está.
</p>
    </blockquote>
  </li>
  <li>
    <p> Ahora empaquetamos utilizando <code>choco pack</code>. Copia el nuevo fichero <code>vagrant.1.8.4.nupkg</code> en <code>c:\packages</code>.
</p>
  </li>
  <li>
    <p> Edita el manifest, y agrega el paquete recién creado. Tu <code>chocolatey.pp</code> debería ser similar a lo siguiente.
</p>

    <pre><code class="language-puppet">package {'vagrant':
  ensure   =&gt; installed,
  provider =&gt; chocolatey,
  source   =&gt; 'c:\packages',
}
</code></pre>
  </li>
  <li>
    <p> Guarda el fichero y estate seguro de validar con el Puppet parser.
</p>
  </li>
  <li>
    <p> Ahora puedes utilizar <code>puppet apply path\to\chocolatey.pp</code> para ejecutar el manifest.
</p>

    <pre><code>Notice: Compiled catalog for win2012r2x64 in environment production in 0.70 seconds
Notice: /Stage[main]/Main/Package[vagrant]/ensure: created
Notice: Applied catalog in 31.51 seconds
</code></pre>
  </li>
  <li>
    <p> Abre Panel de Control, Programas y  Utilidades, echa un vistazo — Vagrant está instalado!
</p>
  </li>
</ol>
<p> <img src="/pe/2017.2/images/windows/choco_vagrant_installed.png" alt="Vagrant is installed!&lt;/p&gt; &lt;p class=" temp-sentence>"&gt;
</p>

<h4 id="uninstalling">Cómo desinstalar</h4>

<p> Para verificar que la característica de  choco <code>autoUninstaller</code> está encendido, use <code>choco feature</code> para listar las características y mostrar el estado actual. Si estás utilizando <code>include chocolatey</code> o <code>class chocolatey</code> para asegurar la instalación de Chocolatey, la configuración se aplicará automáticamente (a menos que lo hayas deshabilitado explícitamente). También, a partir de Chocolatey version <code>0.9.10</code>, está activado por defecto.
</p>

<ol>
<li>
    <p> Si observa <code>autoUninstaller - [Disabled]</code>, usted necesita activarlo. Para hacer esto, en el símbolo de sistema, escribe <code>choco feature enable -n autoUninstaller</code> . Usted debería ver un mensaje positivo similar a:
</p>

    <pre><code>Enabled autoUninstaller
</code></pre>
  </li>
  <li>
    <p> Para eliminar Vagrant, edite su manifest <code>chocolatey.pp</code> a <code>ensure =&gt; absent</code>. Entonces guarde y valide el fichero.
</p>

    <pre><code class="language-puppet">package {'vagrant':
  ensure   =&gt; absent,
  provider =&gt; chocolatey,
  source   =&gt; 'c:\packages',
}
</code></pre>
  </li>
  <li>
    <p> Ahora, ejecute <code>puppet apply path\to\chocolatey.pp</code> para aplicar el manifest.
</p>

    <pre><code>Notice: Compiled catalog for win2012r2x64 in environment production in 0.75 seconds
Notice: /Stage[main]/Main/Package[vagrant]/ensure: removed
Notice: Applied catalog in 40.85 seconds
</code></pre>

    <p> <img src="/pe/2017.2/images/windows/choco_vagrant_uninstalled.png" alt="Vagrant is no longer installed">
</p>

    <p> ¡Y ya no está instalado!
</p>
  </li>
</ol>
<h3 id="real-world-usage-1">Uso en el mundo real</h3>

<p> El ejemplo siguiente asegura que Chocolatey, el Chocolatey Simple Server ( un repositorio interno de paquetes Chocolatey) y  algunos paquetes están instalados. Requiere el module <a href="https://forge.puppetlabs.com/chocolatey/chocolatey_server"><code>chocolatey/chocolatey_server</code> </a>.
</p>

<p> En <code>c:\packages</code> debe tener paquetes para <a href="https://chocolatey.org/packages/chocolatey">Chocolatey</a>, <a href="https://chocolatey.org/packages/chocolatey.server">Chocolatey.Server</a>, <a href="https://chocolatey.org/packages/roundhouse">RoundhousE</a>, <a href="https://chocolatey.org/packages/launchy">Launchy</a>, y <a href="https://chocolatey.org/packages/git">Git</a>, así como cualquiera de sus dependencias.
</p>

<pre><code class="language-puppet">case $operatingsystem {
  'windows':    {
    Package {
      provider =&gt; chocolatey,
      source   =&gt; 'C:\packages',
    }
  }
}

# include chocolatey
class {'chocolatey':
  chocolatey_download_url =&gt; 'file:///C:/packages/chocolatey.0.9.9.11.nupkg',
  use_7zip                =&gt; false,
  log_output              =&gt; true,
}

# This contains the bits to install the custom server.
# include chocolatey_server
class {'chocolatey_server':
  server_package_source =&gt; 'C:/packages',
}

package {'roundhouse':
  ensure   =&gt; '0.8.5.0',
}


package {'launchy':
  ensure          =&gt; installed,
  install_options =&gt; ['-override', '-installArgs','"', '/VERYSILENT','/NORESTART','"'],
}

package {'git':
  ensure =&gt; latest,
}

</code></pre>

<h3 id="want-more-chocolatey">Desea más sobre Chocolatey?</h3>

<p> Usted puede aprender más sobre Chocolatey visitando <a href="https://chocolatey.org">Chocolatey.org</a>, leyendo la <a href="https://github.com/chocolatey/choco/wiki">documentación en GitHub</a>, y visualizando  <a href="https://www.youtube.com/watch?v=NNM2H4GsWYA">“Chocolatey and Puppet - Managing Your Windows Software Since 2011”</a> de Rob Reynolds presentado en PuppetConf 2015. Para aprender específicamente que ofrece el provider y tener una referencia para saber de que es capaz, el module y la documentación están en <a href="https://forge.puppetlabs.com/chocolatey/chocolatey">Puppet Forge</a>.
</p>

